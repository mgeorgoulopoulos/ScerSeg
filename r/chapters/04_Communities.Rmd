---
title: "Histone communities"
output:
  html_document:
    df_print: paged
  pdf_document: default
---

```{r, results="hide", message=FALSE, warning=FALSE, fig.show="hide", echo=FALSE}
library(gplots)
library(plotly)
library(RSQLite)
library(RColorBrewer)
library(clusternor)
```

# Community score

We have calculated the "community score" for each gene.

The score is defined as: A / N, where: 

* A is the average Euclidean distance (in histone space) from the gene to all other genes of the same chromosome.
* N is the average distance of the genes of the local group of 5 genes (+/- 2 genes from the genes we are examining).

We bias the denominator to be 0.17 as a minimum. This corresponds to average of all N minus 3 standard deviations, so as to prevent divisions by zero. The 3 major spikes that can be seen in the picture below are such instances.

```{r warning=FALSE, echo=FALSE}
# Read community scores
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
scores <- dbGetQuery(conn, "SELECT l.Gene, Score FROM Loci l JOIN CommunityScores s ON l.Gene = s.Gene ORDER BY Chromosome, Start")
row.names(scores) <- scores$Gene
#scores <- scores[,names(scores) != "Gene"]
dbDisconnect(conn)
ggplot(scores, aes(x=1:nrow(scores), y=Score)) +
  geom_line() + 
  xlab("Gene number (ordered by chromosome and start position)")

```

# Filtering by community score

We consider a value of '2' as significant. In other words, a gene being twice as similar as their neighbours than its similarity to all other genes in the chromosome is considered a "community center" gene.
Here is a hierarchical clustering of the histone modifications of community centers:

```{r warning=FALSE, echo=FALSE}
# Genes selected for being community-centers
sql <- "SELECT h.* FROM HistonesPromoterPatched h JOIN CommunityScores s ON h.Gene = s.Gene WHERE Score >= 2"
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
centers <- dbGetQuery(conn, sql)
row.names(centers) <- centers$Gene
centers <- centers[,names(centers) != "Gene"]
centers <- as.matrix(centers)
dbDisconnect(conn)

# Do heatmap
clusters <- heatmap.2(centers, main="Community centers", hclustfun=function(d) hclust(d, method="ward.D"))
clusters <- as.hclust(clusters$rowDendrogram)
```


# Deciding number of clusters

We have chosen the community center genes in such a way that we expect clear-cut clusters to be formed in histone space. Plotting the within-cluster total sum of squares we expect to see a clear-cut elbow.

```{r warning=FALSE, echo=FALSE}
maxClusterCount <- 10
withinSS <- sapply(1:maxClusterCount, 
              function(k){kmeans(centers, k, nstart=50,iter.max = 20 )$tot.withinss})
plot(1:maxClusterCount, withinSS,
     type="b", pch = 19, frame = FALSE, 
     xlab="Cluster count",
     ylab="Within-clusters total sum of squares")
 
```

# x-means

It is not easy to decide where the elbow is. I would say it is on 3 clusters, but there's a lot more variance to be explained below that.
Searching for a less ambiguous method, I stumbled upon x-means.

x-means clustering algorithm outputs not only the k clusters, but also k itself. It does so by optimizing an objective function - the Bayesian information criterion - which reveals the mosto likely k. Experiments by the authors have shown it to reveal the true model underlying the data.

```{r}
bicOptimizedClusters <- Xmeans(centers, kmax=10)
Cluster <- bicOptimizedClusters$cluster
centers <- cbind(centers, Cluster)
Cluster
bicOptimizedClusters$size
```
x-means comes up with k=7, which explains most of the variance. Beyond 7 clusters it is evudebt that there's not much to be gained.

Saving the community centers to database in CommunityCenters table, containing Gene name and Community (integer).


```{r results="hide", message=FALSE, warning=FALSE, fig.show="hide"}
# Insert community centers and corresponding cluster ids to db
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
dbExecute(conn, "DROP TABLE IF EXISTS CommunityCenters")
dbExecute(conn, "CREATE TABLE CommunityCenters(Gene TEXT PRIMARY KEY, Community INTEGER)")
for (i in 1:nrow(centers)) {
	sql <- paste("INSERT INTO CommunityCenters(Gene, Community) VALUES('", row.names(centers)[i], "',", centers[i, 10], ")", sep='')
	dbExecute(conn, sql)
}
dbDisconnect(conn)
```

# Community centers in 3D

In this plot we only see the community centers. Each dot represents a gene and implies a group of 5 genes around it, having a similar histone profile.

```{r echo=FALSE}
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
communities <- dbGetQuery(conn, "SELECT l.Gene, x, y, z, Community FROM CommunityCenters c JOIN Loci l ON c.Gene = l.Gene")
plot_ly(x=communities$x, y=communities$y, z=communities$z, type="scatter3d", mode="markers", text=communities$Gene, color=communities$Community)
dbDisconnect(conn)
```

Subsequently, we are going to classify the entire genome using these centers as a scaffold, in histone space.

# Communities in 3D

After classifying all genes using the above scaffold and knn algorithm (k=3), we can plot them in space.

Communities include a central histone-space cluster (aroung zero in all dimensions), which allows us to classify the entire set.
In other words, one of the "extremes" is actually the center of histone space, distant from all other community centers.

```{r echo=FALSE}
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
communities <- dbGetQuery(conn, "SELECT l.Gene, x, y, z, Community FROM Communities c JOIN Loci l ON c.Gene = l.Gene")
plot_ly(x=communities$x, y=communities$y, z=communities$z, type="scatter3d", mode="markers", text=communities$Gene, color=communities$Community)
dbDisconnect(conn)
```

# Communities in 1D

Here is how the communities look in the linear chromosome. Genes are displayed in succession where each gene has a width of 1 pixel:

![Communities on linear chromosome](images/Communities.svg)

# Measuring Shannon entropy

We sample windows of 25 consecutive genes and measure Shannon entropy. Then we sample "clouds" of 25 uniformly random genes (with replacement) and compare the distributions of entropy.

![Shannon entropy distributions for consecutive and cloud (random sets of) genes](images/CommunityEntropyDistributions.svg)

We used a total of 100000 random samples for both windows and clouds.

Unlike the "cloud" distribution which is normal, the "window" distribution differs both in shape and in its displacement towards smaller values.
Its "staircase" shape hints a hierarchy of structure, starting from a set of very low-entropy windows (around 1.2 bits of entropy), two more less structured and more abundant sets at 1.5 and 1.7 bits and finally, after the average has been reached, the distribution collapses to normality.

Probably most interesting result is the first step of the staircase.
This corresponds to a set of windows having around 1.2 bits of entropy. These account for around 1% of the samples.

The entire bubble lies in an area of low (<0.001) p-value with respect to the cloud distribution. An entropy limit of 1.28 bits corresponds to that p-value. We can filter our windows based on that.

# Tight communities

Windows of 25 genes, filtered for a maximum of 1.28 bits of entropy.

## 2D view

![Tight communities on linear chromosome](images/TightCommunities.svg)

## 3D view

```{r echo=FALSE}
conn <- dbConnect(RSQLite::SQLite(), "../../Results/yeast.sqlite")
tightCommunities <- dbGetQuery(conn, "SELECT Gene, x, y, z, CASE WHEN Gene IN (SELECT Gene FROM TightCommunities) THEN 'Tight' ELSE 'Random' END AS Tightness FROM Loci")
plot_ly(x=tightCommunities$x, y=tightCommunities$y, z=tightCommunities$z, type="scatter3d", mode="markers", text=tightCommunities$Gene, color=tightCommunities$Tightness, colors=c("#000000", "#FF0000"))
dbDisconnect(conn)
```





